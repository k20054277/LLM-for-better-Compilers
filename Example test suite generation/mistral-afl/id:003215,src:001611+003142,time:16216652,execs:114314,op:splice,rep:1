
import threading
import time

# Define semaphore with initial value 2
semaphore = threading.Semaphore(2)

def task(thread_id):
    print(f"Thread {thread_id} started")
    semaphore.acquire()
    print(f"Thread {thread_id}: I have the resource now")
    time.sleep(1)
    semaphore.release()
    print(f"Thread {thread_id} finished")

if __name__ == "__main__":
    threads = [threading.Thread(target=lambda: task(i), args=(i,)) for i in range(5)]
    for thread in thr
def outer_function(x, y):
    def inner_function():
        nonlocal x, y  # Declare that x and y are nonlocal variables
import sqlite3

# Create a new SQLite database with the given name.
def create_connection(db_file):
 db = None
 try:
     db = sqlite3.connect(db_file)
 except sqlite3.Error as e:
     print(e)
 return db

# Create a table in the SQLite database with the given name and columns.
def create_table(db, table_name, columns):
 try:
     cursor = db.cursor()
     cursor.execute(f'CREATE TABLE IF NOT EXISTS {table_name} ({", ".join([f"{col[0]} {col[1]}" for col in columns])});')
 except sqlite3.Error as e:
     print(e)

# Insert a new row into the given table with the given key-value pairs.
def iosert_into_table(db, table_name, data):
 try:
     cursor = db.cursor()
     keys, values = zip(*data.items())
     query = f'INSERT INTO {table_name} VALUES ({", ".join(["?" for _ in keys])});'
     cursor.execute(query, tuple(values))
     db.commit()
 except sqlite3.Error as e:
     print(e)

# Query the SQLite database and return all rows from the given table.
def query_table(db, table_name):
 try:
     cursor = db.cursor()
     cursor.execute(f"SELECT * FROM {table_name};")
     rows = cursor.fetchall()
     return rows
 except sqlite3.Error as e:
     print(e)
     return []

# Main function dem